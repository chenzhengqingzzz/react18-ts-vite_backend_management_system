# React18+TypeScript+Vite 的通用后台管理系统

Ant Design of React官网：https://ant.design/docs/react/introduce-cn

# 一、创建项目

```shell
npm init vite
Project name: lege-management
select a framework: react
select a variant: react-ts
```

打开package.json,参考以下个模块版本：

`src/package.json`

```json
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-redux": "^7.2.8",
    "react-router-dom": "^6.3.0",
    "redux": "^4.1.2",
  },
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230624150347234.png" alt="image-20230624150347234" style="zoom:67%;" />

# 二、项目目录初始化

`src/main.tsx`修改成：

```tsx
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'

ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
```

`src/App.tsx`修改成：

```tsx
import { useState } from 'react'

function App() {
  const [count, setCount] = useState(0)

  return (
    <div className='App'>
      顶级组件
    </div>
  )
}

export default App
```

# 三、样式初始化

我们可以用`reset-css`这个库干净利落地去除默认样式，更适合在企业中使用

执行命令安装`reset-css`：

```shell
npm i reset-css
```

`src/main.tsx`引入`reset-css`

```tsx
import React from 'react'
import ReactDOM from 'react-dom/client'
// 全局引入reset-css 样式初始化一般放在最前
import 'reset-css'
// UI框架的样式

// 组件的样式

import App from './App.tsx'
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230623181647455.png" alt="image-20230623181647455" style="zoom:67%;" />

# 四、SCSS的安装和初步使用

安装sass：

```shell
# 安装sass vite中很方便 loader这些都不用自己配置 只需要安装好即可使用
npm i --save-dev sass
```

src新建样式文件夹：

`src/assets/styles`

```scss
$color: pink;
body {
    background-color: $color;
    // 禁止文字选中
    user-select: none;
}

img {
    // 禁止拖动图片
    -webkit-user-drag: none;
}
```

在入口文件引入这个全局样式

`src/main.tsx`

```tsx
// 全局样式
import './assets/styles/global.scss'
```

我们在全局样式里设置了无法拖动图片 无法选中文字等一系列操作 并且设置了背景图片

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230623183026031.png" alt="image-20230623183026031" style="zoom:67%;" />

# 五、配置项目路径别名

## 5.1 路径别名的配置

目前ts对@指向src目录的提示是不支持的，vite默认也是不支持的

所以需要手动配置@符号的指向

`src/vite.config.ts`

```ts
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import path from 'path';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src')
    }
  }
})
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230623184413734.png" alt="image-20230623184413734" style="zoom:67%;" />

这时候引入path模块会爆红，但其实我们已经已经有node环境，所以就一定会有path模块，只是因为ts的语言特性，缺少了一些声明配置

所以需要安装关于node这个库的ts声明配置

```shell
npm i -D @types/node
```

安装成功就不会爆红了 如果import后面的path爆红，就把引入换成`import * as path from 'path'`

这之后我们就可以把@符号指代成src了 是绝对路径

## 5.2 配置路径别名的提示

虽然现在路径别名已经有了，但是在文件中输入@是没有提示路径的

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230623190032546.png" alt="image-20230623190032546" style="zoom:67%;" />

需要我们在`tsconfig.json`中添加两项配置

`src/tsconfig.json`

```json
    "baseUrl": "./",
    "paths": {
      "@/*": [
        "src/*"
      ]
    },
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230624144450710.png" alt="image-20230624144450710" style="zoom:67%;" />

这样就会有了提示

# 六、SCSS模块化

## 6.1 SCSS的进一步使用

在src下新建components文件夹

components文件夹下新建Comp1文件夹，新建index.tsx和comp1.scss

`src/components/Comp1/index.tsx`

```tsx
/*
 * @Author: czqczqzzzzzz(czq)
 * @Email: tenchenzhengqing@qq.com
 * @Date: 2023-06-24 14:48:58
 * @LastEditors: 陈正清MacPro
 * @LastEditTime: 2023-06-24 15:13:17
 * @FilePath: /react18+ts+vite后台管理系统/vite-project/src/components/Comp1/index.tsx
 * @Description: 测试组件Comp1
 * 
 * Copyright (c) by czqczqzzzzzz(czq), All Rights Reserved.
 */

// 引入当前文件夹下的样式
import './comp1.scss'  // 全局引入
function Comp1(){
    return (
        <div className="box">
            <p>这是Comp1组件里面的内容</p>
        </div>
    )
}

export default Comp1
```

`src/components/Comp1/index.scss`

```scss
.box {
    color: red;
}
```

components文件夹新建Comp2文件夹，新建index.tsx

`src/components/Comp2/index.tsx`

```tsx
/*
 * @Author: czqczqzzzzzz(czq)
 * @Email: tenchenzhengqing@qq.com
 * @Date: 2023-06-24 15:07:12
 * @LastEditors: 陈正清MacPro
 * @LastEditTime: 2023-06-24 15:10:48
 * @FilePath: /react18+ts+vite后台管理系统/vite-project/src/components/Comp2/index.tsx
 * @Description: 测试组件Comp2
 * 
 * Copyright (c) by czqczqzzzzzz(czq), All Rights Reserved.
 */
 
 //注意：在Comp2组件汇总不引入上面的comp1.scss样式
export default function Comp2() {
  return (
    <div className="box">
        <p>这是Comp2组件里面的内容</p>
    </div>
  )
}
```

在App.tsx注册这两个组件：

`src/App.tsx`

```tsx
import { useState } from 'react'
import Comp1 from './components/Comp1'
import Comp2 from './components/Comp2'

function App() {
  const [count, setCount] = useState(0)

  return (
    <div className='App'>
      顶级组件
      <Comp1></Comp1>
      <Comp2></Comp2>
    </div>
  )
}

export default App
```

## 6.2 SCSS的模块化

将comp1.scss改名为comp1.moudle.scss

`src/components/Comp1/index.tsx`

```tsx
// 引入当前文件夹下的样式
// import './comp1.scss'  // 全局引入

// scss模块化引入
import styles from './comp1.module.scss'
function Comp1(){
    return (
        <div className={styles.box}>
            <p>这是Comp1组件里面的内容</p>
        </div>
    )
}

export default Comp1
```

这个实现的效果就类似于vue中的style = scoped写法

`src/components/Comp1/comp1.moudle.scss`

```scss
.box {
    color: red;
    
    p {
        margin-top: 100px;
    }
}
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230624154319245.png" alt="image-20230624154319245" style="zoom:67%;" />

**！！注意：styles.box的box在.module.scss文件中只能是类名，标签名字不起作用**

# 七、AntDesign的初步引入

安装AntDesign

```shell
// 使用 npm 安装
npm install antd --save
// 使用 yarn 安装
yarn add antd
```

安装图标所需要的模块

```shell
// 使用 npm 安装
npm install --save @ant-design/icons
// 使用 yarn 安装
yarn add @ant-design/icons
```

在App组件中引入并使用

`src/App.tsx`

```tsx
/*
 * @Author: czqczqzzzzzz(czq)
 * @Email: tenchenzhengqing@qq.com
 * @Date: 2023-06-23 16:19:13
 * @LastEditors: 陈正清MacPro
 * @LastEditTime: 2023-06-24 16:14:07
 * @FilePath: /react18+ts+vite后台管理系统/vite-project/src/App.tsx
 * @Description: 所有组件的父组件App
 * 
 * Copyright (c) by czqczqzzzzzz(czq), All Rights Reserved.
 */
import { useState } from 'react'
import Comp1 from './components/Comp1'
import Comp2 from './components/Comp2'
import { Button } from 'antd'
import 'antd/dist/antd.css' // or 'antd/dist/antd.less'
import { FastBackwardOutlined } from '@ant-design/icons'

function App() {
  const [count, setCount] = useState(0)

  return (
    <div className='App'>
      顶级组件
      <Comp1></Comp1>
      <Comp2></Comp2>
      <Button type='primary'>Primary Button</Button>
      <FastBackwardOutlined style={{fontSize: '40px', color: '#08c'}} />
    </div>
  )
}

export default App

```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230624162543224.png" alt="image-20230624162543224" style="zoom:67%;" />

# 八、配置Antd Design样式自动按需引入

antd的4.x版本以上已经支持按需引入，我们只需要解决样式上的自动按需引入即可

安装插件vite-plugin-style-import

```shell
npm install vite-plugin-style-import@1.4.1 -D
```

在vite.config.ts中进行配置

`src/vite.config.ts`

```ts
import styleImport,{AntdResolve} from 'vite-plugin-style-import';
export default defineConfig({
  plugins: [
    react(),
    styleImport({
      resolves: [
        AntdResolve()
      ],
    }),
  ],
  ...
})
```

然后我们就可以去掉App.tsx中的`import 'antd/dist/antd.css' // or 'antd/dist/antd.less' `这一行样式引入

启动项目，发现报错，缺少less，则我们开始安装less

```shell
npm i less@2.7.1 -D
```

这样就实现了按需引入antd，节省性能

# 九、React路由——第一种配置方案（旧项目中的写法）

## 9.1 初步展示

我们在这里模拟Vue中的Home和About两个组件的展示

1. 【准备界面】首先在src下创建views文件夹 然后准备两个目标组件

`src/views/Home.tsx`

```tsx
/*
 * @Author: czqczqzzzzzz(czq)
 * @Email: tenchenzhengqing@qq.com
 * @Date: 2023-06-24 18:15:11
 * @LastEditors: 陈正清MacPro
 * @LastEditTime: 2023-06-24 19:07:21
 * @FilePath: /react18+ts+vite后台管理系统/vite-project/src/views/Home.tsx
 * @Description: 路由写法 About组件
 * 
 * Copyright (c) by czqczqzzzzzz(czq), All Rights Reserved.
 */
const View = () => {
    return (
        <div className="home">
            <p>这是Home组件</p>
        </div>
    )
}

export default View
```

`src/views/Aboue.tsx`

```tsx
/*
 * @Author: czqczqzzzzzz(czq)
 * @Email: tenchenzhengqing@qq.com
 * @Date: 2023-06-24 18:15:11
 * @LastEditors: 陈正清MacPro
 * @LastEditTime: 2023-06-24 19:07:15
 * @FilePath: /react18+ts+vite后台管理系统/vite-project/src/views/About.tsx
 * @Description: 路由写法 Home组件
 * 
 * Copyright (c) by czqczqzzzzzz(czq), All Rights Reserved.
 */
const View = () => {
    return (
        <div className="home">
            <p>这是About组件</p>
        </div>
    )
}

export default View
```

2. 【配置对应关系】/src下新建router文件夹 再在里面创建index.tsx

`src/router/index.tsx`

```tsx
/*
 * @Author: czqczqzzzzzz(czq)
 * @Email: tenchenzhengqing@qq.com
 * @Date: 2023-06-24 18:18:16
 * @LastEditors: 陈正清MacPro
 * @LastEditTime: 2023-06-24 18:28:00
 * @FilePath: /react18+ts+vite后台管理系统/vite-project/src/router/index.tsx
 * @Description: React路由
 *
 * Copyright (c) by czqczqzzzzzz(czq), All Rights Reserved.
 */
import App from "@/App";
import Home from "@/views/Home";
import About from "@/views/About";
import { BrowserRouter, Routes, Route } from "react-router-dom";
// 两种路由模式的组件： BrowserRouter ( History模式 ) ， HashRouter( Hash模式 )


const router = () => {
  return (
    <BrowserRouter>
      <Routes>
        <Route path="/" element={<App />}>
          <Route path="/home" element={<Home />}></Route>
          <Route path="/about" element={<About />}></Route>
        </Route>
      </Routes>
    </BrowserRouter>
  );
};

export default router;
```

3. 【替换顶级组件】 在src/main.tsx中把顶级组件**App替换为这个路由对象**

```tsx
...
ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(
  <React.StrictMode>
    <Router />
  </React.StrictMode>,
)
```

4. 【添加窗口组件】/src/App.tsx中，使用组件Outlet作为占位符组件

`src/App.tsx`

```tsx
...
function App() {
  const [count, setCount] = useState(0)

  return (
    <div className='App'>
      {/* 顶级组件
      <Comp1></Comp1>
      <Comp2></Comp2>
      <Button type='primary'>Primary Button</Button>
      <FastBackwardOutlined style={{fontSize: '40px', color: '#08c'}} /> */}

      {/* 占位符组件 类似于窗口，用来展示组件 有点像Vue中的router-view */}
      <Outlet></Outlet>
    </div>
  )
}

export default App
```

这样在浏览器中访问对应的路由url 就能够看到路由组件了

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230624193022014.png" alt="image-20230624193022014" style="zoom:67%;" />

## 9.2 编程式导航——设置点击跳转

在App.tsx中，使用组件进行跳转

```tsx
import { Link, Outlet } from 'react-router-dom'

function App() {

  return (
    <div className='App'>
      <Link to='/home'>Home</Link>
      <Link to='/about'>About</Link>
      {/* 占位符组件 类似于窗口，用来展示组件 有点像Vue中的router-view */}
      <Outlet></Outlet>
    </div>
  )
}

export default App

```

这里我们使用到了link组件 类似于Vue中的router-link

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230624194541287.png" alt="image-20230624194541287" style="zoom:67%;" />

## 9.3 配置重定向

`src/router/index.tsx`

我们需要借助Navigate这个标签实现路由的重定向

```tsx
import {BrowserRouter,Routes,Route,Navigate} from "react-router-dom"
...
<Route path="/" element={<App/>}>
    {/* 配置 用户访问/的时候，重定向到/home路径 */}
    <Route path="/" element={<Navigate  to="/home" />}></Route>
    ...
</Route>
```

# 十、React路由——第二种配置方案

## 10.1 路由表的写法

和上面一样，在这里模拟Vue中的Home和About两个组件的战士

1. 【准备界面】在上面已经完成
2. 【配置对应关系】

`src/router/inedx.tsx`

```tsx
import Home from '@/views/Home';
import About from '@/views/About'
import { Navigate } from 'react-router-dom';
const routes = [
    {
        path: '/',
        element: <Navigate to='/home' /> // 使用重定向组件 重定向到Home
    },

    {
        path: '/home',
        element: <Home />
    },

    {
        path: 'about',
        element: <About />
    }
]

export default routes
```

3. 【路由组件的添加】在src/main.tsx中在App组件外层包裹路由标签 跟上面的不一样 我们这里用的是App组件

`src/main.tsx`

```tsx
import App from "./App.tsx";
import { BrowserRouter } from "react-router-dom";
// import Router from '@/router';

ReactDOM.createRoot(document.getElementById("root") as HTMLElement).render(
  <React.StrictMode>
    <BrowserRouter>
      <App/>
    </BrowserRouter>
  </React.StrictMode>
);
```

4. 【添加窗口组件】src/App.tsx中，使用hooks来创建占位符

`src/App.tsx`

这里的{outlet}对象是使用了 useRoutes这个hooks的缘故 它的作用和<Outlet>一样 都充当占位符

```tsx
import { Link, useRoutes } from 'react-router-dom'
import router from '@/router'

function App() {
  const outlet = useRoutes(router)
  return (
    <div className='App'>
      <Link to='/home'>Home</Link>
      <Link to='/about'>About</Link>

      {/* 占位符组件 类似于窗口，用来展示组件 有点像Vue中的router-view */}
      {/* <Outlet></Outlet> */}

      {/* Hook形式生成的对象 */}
      {outlet}
    </div>
  )
}

export default App

```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230624203359616.png" alt="image-20230624203359616" style="zoom:67%;" />

我们将实现同样的效果 更推荐使用React18中的Hooks

## 10.2 路由懒加载

由于我们路由重定向，一来我们会看到Home组件，所以它没有必要做懒加载 所以我们打算把About组件做成懒加载组件：

`src/router/index.tsx`

```tsx
import { lazy } from "react"
// 由于我们规定Home组件一上来就能看到 给它做懒加载的意义不大
import Home from '@/views/Home';
...
const About lazy(() => import('@/view/About'))

const routes = [
    {
        path: '/',
        element: <Navigate to='/home' /> // 使用重定向组件 重定向到Home
    },

    {
        path: '/home',
        element: <Home />
    },

    {
        path: '/about',
        // 使用懒加载的组件的写法，外面需要套一层类似Loading的标签来向用户提示加载组件
        element: <About/>
    }
]
```

## 10.3 懒加载组件需要嵌套Loading组件的报错解决

接上节，我们在给About组件使用懒加载，在写好并测试的时候会发现有错误

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230624210024390.png" alt="image-20230624210024390" style="zoom:67%;" />

这是因为React要求我们使用懒加载的时候，必须在使用懒加载的组件外面外面套一层类似Loading的标签来向用户提示加载组件

这个时候我们就需要用到React要求的<React.Suspense></React.Suspense>这个标签包裹我们的懒加载组件 这个标签有个属性fallback 用来传Loading类似的提示信息

`src/router/index.ts`

```tsx
// 使用懒加载
import React, { lazy } from "react";
...

const routes = [
    ...
    {
        path: '/about',
        // 使用懒加载的组件的写法，外面需要套一层类似Loading的标签来向用户提示加载组件
        element: <React.Suspense fallback={<div>Loading...</div>}>
            <About/>
        </React.Suspense>
    }
]

export default routes
```

这样就完美的解决了这个错误 在加载期间也有Loading标识了 当然个人认为为 这个等待加载的标签可以使用UI库的样式来让网站体验更好

**简化后的写法**

我们会发现 在做项目的时候使用多个懒加载组件，我们都会在组件外面套一下<React.Suspense>的标签，我们可以把这个封装成一个函数，用来在我们每次书写时候的代码复用

`src/router/index.tsx`

```tsx
...
/**
 * @description: 将懒加载的组件外层包裹一个React.Suspense标签 用来展示加载中的组件
 * @param {JSX.Element} lazyLoadComponentTagName 需要进行懒加载的组件
 * @return {JSX.Element}
 */
const withLazyLoadComponent = (lazyLoadComponentTagName: JSX.Element) => {
    return (
        <React.Suspense fallback={<div>Loading...</div>}>
            {lazyLoadComponentTagName}
        </React.Suspense>
    )
}

const routes = [
    ...

    {
        path: '/about',
        // 使用懒加载的组件的写法，外面需要套一层类似Loading的标签来向用户提示加载组件
        element: withLazyLoadComponent(<About/>)
    }
]

export default routes
```

将相同的代码进行封装，实现代码复用 这就是简化后的写法

# 十一、布局解决方案——Layout组件（含侧边栏）

布局组件文档：https://4x.ant.design/components/layout-cn/#header

注意：不要直接点复制代码，先展开代码部分，里面也包含了样式代码。如果直接点了复制代码，则样式代码不会被复制

## 11.1 初步使用

`src/App.tsx`

```tsx
import { useRoutes } from 'react-router-dom'
import router from '@/router'

function App() {
  const outlet = useRoutes(router)
  return (
    <div className='App'>
      {outlet}
    </div>
  )
}

export default App
```

`src/views/Home.tsx`

```tsx
/*
 * @Author: czqczqzzzzzz(czq)
 * @Email: tenchenzhengqing@qq.com
 * @Date: 2023-06-24 18:15:11
 * @LastEditors: 陈正清macbook pro
 * @LastEditTime: 2023-06-25 18:03:59
 * @FilePath: /react18-ts-vite_backend_management_system/vite-project/src/views/Home.tsx
 * @Description: Home首页组件
 * 
 * Copyright (c) by czqczqzzzzzz(czq), All Rights Reserved.
 */
import {
    DesktopOutlined,
    FileOutlined,
    PieChartOutlined,
    TeamOutlined,
    UserOutlined,
  } from '@ant-design/icons';
  import type { MenuProps } from 'antd';
  import { Breadcrumb, Layout, Menu } from 'antd';
  import React, { useState } from 'react';
  
  const { Header, Content, Footer, Sider } = Layout;
  
  type MenuItem = Required<MenuProps>['items'][number];
  
  function getItem(
    label: React.ReactNode,
    key: React.Key,
    icon?: React.ReactNode,
    children?: MenuItem[],
  ): MenuItem {
    return {
      key,
      icon,
      children,
      label,
    } as MenuItem;
  }
  
  const items: MenuItem[] = [
    getItem('Option 1', '1', <PieChartOutlined />),
    getItem('Option 2', '2', <DesktopOutlined />),
    getItem('User', 'sub1', <UserOutlined />, [
      getItem('Tom', '3'),
      getItem('Bill', '4'),
      getItem('Alex', '5'),
    ]),
    getItem('Team', 'sub2', <TeamOutlined />, [getItem('Team 1', '6'), getItem('Team 2', '8')]),
    getItem('Files', '9', <FileOutlined />),
  ];
  
  const Home: React.FC = () => {
    const [collapsed, setCollapsed] = useState(false);
  
    return (
      <Layout style={{ minHeight: '100vh' }}>
        <Sider collapsible collapsed={collapsed} onCollapse={value => setCollapsed(value)}>
          <div className="logo" />
          <Menu theme="dark" defaultSelectedKeys={['1']} mode="inline" items={items} />
        </Sider>
        <Layout className="site-layout">
          <Header className="site-layout-background" style={{ padding: 0 }} />
          <Content style={{ margin: '0 16px' }}>
            <Breadcrumb style={{ margin: '16px 0' }}>
              <Breadcrumb.Item>User</Breadcrumb.Item>
              <Breadcrumb.Item>Bill</Breadcrumb.Item>
            </Breadcrumb>
            <div className="site-layout-background" style={{ padding: 24, minHeight: 360 }}>
              Bill is a cat.
            </div>
          </Content>
          <Footer style={{ textAlign: 'center' }}>Ant Design ©2018 Created by Ant UED</Footer>
        </Layout>
      </Layout>
    );
  };
  
  export default Home;
```

我们在global.scss加入官网开源的样式：

`src/assets/styles/global.scss`

```scss
$color: pink;
body {
    background-color: $color;
    // 禁止文字选中
    user-select: none;
}

img {
    // 禁止拖动图片
    -webkit-user-drag: none;
}

// 首页我布局样式
.logo {
    height: 32px;
    margin: 16px;
    background: rgba(255, 255, 255, 0.3);
  }
  
  .site-layout .site-layout-background {
    background: #fff;
  }
```

调试页面：

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230625181909382.png" alt="image-20230625181909382" style="zoom:50%;" />

## 11.2 右侧样式调整

`src/views/Home.tsx`

```tsx
/*
 * @Author: czqczqzzzzzz(czq)
 * @Email: tenchenzhengqing@qq.com
 * @Date: 2023-06-24 18:15:11
 * @LastEditors: 陈正清macbook pro
 * @LastEditTime: 2023-06-25 20:53:26
 * @FilePath: /react18-ts-vite_backend_management_system/vite-project/src/views/Home.tsx
 * @Description: Home首页组件
 *
 * Copyright (c) by czqczqzzzzzz(czq), All Rights Reserved.
 */
import {
  DesktopOutlined,
  FileOutlined,
  PieChartOutlined,
  TeamOutlined,
  UserOutlined,
} from "@ant-design/icons";
import type { MenuProps } from "antd";
import { Breadcrumb, Layout, Menu } from "antd";
import React, { useState } from "react";

const { Header, Content, Footer, Sider } = Layout;

type MenuItem = Required<MenuProps>["items"][number];

function getItem(
  label: React.ReactNode,
  key: React.Key,
  icon?: React.ReactNode,
  children?: MenuItem[]
): MenuItem {
  return {
    key,
    icon,
    children,
    label,
  } as MenuItem;
}

const items: MenuItem[] = [
  getItem("Option 1", "1", <PieChartOutlined />),
  getItem("Option 2", "2", <DesktopOutlined />),
  getItem("User", "sub1", <UserOutlined />, [
    getItem("Tom", "3"),
    getItem("Bill", "4"),
    getItem("Alex", "5"),
  ]),
  getItem("Team", "sub2", <TeamOutlined />, [
    getItem("Team 1", "6"),
    getItem("Team 2", "8"),
  ]),
  getItem("Files", "9", <FileOutlined />),
];

const Home: React.FC = () => {
  const [collapsed, setCollapsed] = useState(false);

  return (
    <Layout style={{ minHeight: "100vh" }}>
      {/* 左侧侧边栏 */}
      <Sider
        collapsible
        collapsed={collapsed}
        onCollapse={(value) => setCollapsed(value)}
      >
        <div className="logo" />
        <Menu
          theme="dark"
          defaultSelectedKeys={["1"]}
          mode="inline"
          items={items}
        />
      </Sider>
      {/* 右边内容 */}
      <Layout className="site-layout">
        {/* 右边头部 */}
        <Header className="site-layout-background" style={{ paddingLeft: '16px' }}>
          {/* 面包屑 */}
          <Breadcrumb style={{ lineHeight: '64px' }}>
            <Breadcrumb.Item>User</Breadcrumb.Item>
            <Breadcrumb.Item>Bill</Breadcrumb.Item>
          </Breadcrumb>
        </Header>
        {/* 右边内容 */}
        <Content className="site-layout-background" style={{ margin: "16px 16px 0" }}>
            {/* 页面展示部分 根据路由变动 */}
        </Content>
        {/* 右边底部 */}
        <Footer style={{ textAlign: "center", padding: 0, lineHeight: '48px' }}>
          Ant Design ©2018 Created by Ant UED
        </Footer>
      </Layout>
    </Layout>
  );
};

export default Home;

```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230625233003655.png" alt="image-20230625233003655" style="zoom:50%;" />

在组件标签里面调整了部分样式对齐

# 十二、侧边栏的点击实现跳转

## 12.1 侧边栏的点击事件

我们观察页面布局，左侧侧边栏的项目名字都传入了Menu这个组件中

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230701130427831.png" alt="image-20230701130427831" style="zoom:50%;" />

所以我们打算在相应的代码里面绑定对应的点击事件

`src/views/Home.tsx`

```tsx
      {/* 左侧侧边栏 */}
      <Sider
        collapsible
        collapsed={collapsed}
        onCollapse={(value) => setCollapsed(value)}
      >
        <div className="logo" />
        <Menu
          theme="dark"
          defaultSelectedKeys={["1"]}
          mode="inline"
          items={items}
          onClick={menuClick}
        />
      </Sider>
```

在return前面定义相应的函数：

```tsx
const menuClick = (e) => {
  console.log(e);
  
  // 点击跳转到对应的路由
	...
}
```

这边发现在上面的items里面中 getItem传入的第二个参数就是key值 

```tsx
const items: MenuItem[] = [
  getItem("Option 1", "1", <PieChartOutlined />),
  getItem("Option 2", "2", <DesktopOutlined />),
  getItem("User", "sub1", <UserOutlined />, [
    getItem("Tom", "3"),
    getItem("Bill", "4"),
    getItem("Alex", "5"),
  ]),
  getItem("Team", "sub2", <TeamOutlined />, [
    getItem("Team 1", "6"),
    getItem("Team 2", "8"),
  ]),
  getItem("Files", "9", <FileOutlined />),
];
```

![image-20230701131512982](/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230701131512982.png)

我们在这个函数处理的是点击之后进行路由跳转，我们可以将这个key设为我们要跳转的路由路径，我们规定它的类型为string，传入的是路由的path

```tsx
const items: MenuItem[] = [
  getItem("Option 1", "/page1", <PieChartOutlined />),
  getItem("Option 2", "/page2", <DesktopOutlined />),
  getItem("User", "sub1", <UserOutlined />, [
    getItem("Tom", "3"),
    getItem("Bill", "4"),
    getItem("Alex", "5"),
  ]),
  getItem("Team", "sub2", <TeamOutlined />, [
    getItem("Team 1", "6"),
    getItem("Team 2", "8"),
  ]),
  getItem("Files", "9", <FileOutlined />),
];

...

/**
 * @description: 点击侧边菜单栏的点击事件回调
 * @param {*} e 事件对象
 * @return {*}
 */
const menuClick = (e: {key: string}) => {
  console.log(e);
  
  // 点击跳转到对应的路由

}
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230701131918644.png" alt="image-20230701131918644" style="zoom:50%;" />

## 12.2 配置点击跳转和占位符的展示窗口

`src/views/Home.tsx`

```tsx
import { useNavigate, Outlet } from "react-router-dom";
...
const Home: React.FC = () => {
  const [collapsed, setCollapsed] = useState(false);
  const navigateTo = useNavigate();

  /**
   * @description: 点击侧边菜单栏的点击事件回调
   * @param {*} e 事件对象
   * @return {*}
   */
  const menuClick = (e: { key: string }) => {
    // 点击跳转到对应的路由 编程式导航跳转 需要用到useNavigate这个Hook
    navigateTo(e.key)
  };
  ...
  }
```

我们已经利用Hook写好了触发路由跳转的函数 此时我们还需要配置路由表才能实现点击跳转

## 12.3  嵌套路由的配置

我们还需要在路由表中进行配置(记得在views中准备好Pages1和Pages2两个组件)

```tsx
// 定义懒加载模块
const Page1 = lazy(() => import('@/views/Page1'))
const Page2 = lazy(() => import('@/views/Page2'))
...

const routes = [
    // 嵌套路由 开始------------------
    {
        // 这里是配置重定向到page1
        path: '/',
        element: <Navigate to='/page1' /> // 使用重定向组件 重定向到Page1
    },
    {
        // 定义展示home路由及其子路由
        path: '/',
        element: <Home/>,
        children: [
            {
                path: '/page1',
                element: withLazyLoadComponent(<Page1/>)
            },
            {
                path: '/page2',
                element: withLazyLoadComponent(<Page2/>)
            },
        ]
    },
    // 嵌套路由 结束------------------
    ...
]
```

我们配置好后对应路由关系如下：

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230701135839238.png" alt="image-20230701135839238" style="zoom:50%;" />

# 十三、侧边栏的收缩和展开做调整

页面一刷新的时候，我们要求默认选中第一个栏目，在Home页面中，将默认选中的key数组更换一下

`src/views/Home.tsx`

```tsx
...
				<Menu
          theme="dark"
          defaultSelectedKeys={["/page1"]}
          mode="inline"
          items={items}
          onClick={menuClick}
        />
...
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230706115743637.png" alt="image-20230706115743637" style="zoom:50%;" />

接下来我们想要完成点击展开新一项的时候其他项目收起来，我们根据Antd文档，决定在Home页面的Menu组件补充一个属性和一个事件：

```tsx
const Home: React.FC = () => {
...

  /**
   * @description: 展开和关闭某项菜单的时候执行回调
   * @param {Array} keys 记录了当前被展开项目的key的数组
   * @return {*}
   */
  const handleMenuOpenChange = (keys: string[]) => {
    console.log(keys);
    // 把这个数组修改成openKeys存入的东西 我们只需要一项展开
    setOpenKeys([keys[keys.length - 1]])
  }

  // 定义控制当前展开项目的state，这个数组决定哪一项展开里面存啥我们就把key存进去
  const [openKeys, setOpenKeys] = useState([''])

  return (
...
        <Menu
          theme="dark"
          defaultSelectedKeys={["/page1"]}
          mode="inline"
          items={items}
          onClick={menuClick}
          // 某项菜单展开和回收的事件
          onOpenChange={handleMenuOpenChange}
          // 当前展开的菜单项key数组
          openKeys={openKeys}
        />
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230706120203524.png" alt="image-20230706120203524" style="zoom:50%;" />

这里我们将openKeys传入了state中，在我们点击菜单栏展开或关闭的时候将keys（存当前展开的项目key）最后一项通过setState存入openKeys中，来实现只展开我们最后一个项目

# 十四、MainMenu组件的抽取

Menu组件有它独立的业务逻辑，需要处理成子组件

我们决定在components中新建MainMenu组件 把Home.tsx中的Menu部分抽取过来：

`src/components/MainMenu/index.tsx`

```tsx
/*
 * @Author: czqczqzzzzzz(czq)
 * @Email: tenchenzhengqing@qq.com
 * @Date: 2023-07-06 12:10:07
 * @LastEditors: 陈正清MacPro
 * @LastEditTime: 2023-07-06 14:06:19
 * @FilePath: /react18+ts+vite后台管理系统/vite-project/src/components/MainMenu/index.tsx
 * @Description: 公用组件MainMenu，页面左侧主菜单
 *
 * Copyright (c) by czqczqzzzzzz(czq), All Rights Reserved.
 */
import {
  DesktopOutlined,
  FileOutlined,
  PieChartOutlined,
  TeamOutlined,
  UserOutlined,
} from "@ant-design/icons";
import type { MenuProps } from "antd";
import { Menu } from "antd";
import { useState } from "react";
import { useNavigate } from "react-router-dom";



type MenuItem = Required<MenuProps>["items"][number];

function getItem(
  label: React.ReactNode,
  key: React.Key,
  icon?: React.ReactNode,
  children?: MenuItem[]
): MenuItem {
  return {
    key,
    icon,
    children,
    label,
  } as MenuItem;
}

const items: MenuItem[] = [
  getItem("Option 1", "/page1", <PieChartOutlined />),
  getItem("Option 2", "/page2", <DesktopOutlined />),
  getItem("User", "page3", <UserOutlined />, [
    getItem("Tom", "3"),
    getItem("Bill", "4"),
    getItem("Alex", "5"),
  ]),
  getItem("Team", "page4", <TeamOutlined />, [
    getItem("Team 1", "6"),
    getItem("Team 2", "8"),
  ]),
  getItem("Files", "9", <FileOutlined />),
];

const MainMenu: React.FC = () => {
  const navigateTo = useNavigate()

  /**
   * @description: 点击侧边菜单栏的点击事件回调
   * @param {*} e 事件对象
   * @return {*}
   */
  const menuClick = (e: {key: string}) => {
    // 点击跳转到对应的路由 编程式导航跳转 需要用到useNavigate这个Hook
    navigateTo(e.key)
    
  };

  /**
   * @description: 展开和关闭某项菜单的时候执行回调
   * @param {Array} keys 记录了当前被展开项目的key的数组
   * @return {*}
   */
  const handleMenuOpenChange = (keys: string[]) => {
    console.log(keys);
    // 把这个数组修改成openKeys存入的东西 我们只需要一项展开
    setOpenKeys([keys[keys.length - 1]]);
  };

  // 定义控制当前展开项目的state，这个数组决定哪一项展开里面存啥我们就把key存进去
  const [openKeys, setOpenKeys] = useState([''])

  return (
    <Menu
      theme="dark"
      defaultSelectedKeys={["/page1"]}
      mode="inline"
      items={items}
      onClick={menuClick}
      // 某项菜单展开和回收的事件
      onOpenChange={handleMenuOpenChange}
      // 当前展开的菜单项key数组
      openKeys={openKeys}
    />
  );
};

export default MainMenu;

```

修改后的Home：

`src/views/Home.tsx`

```tsx
import { Breadcrumb, Layout } from "antd";
import React, { useState } from "react";
import { useNavigate, Outlet } from "react-router-dom";
import MainMenu from "@/components/MainMenu";

const { Header, Content, Footer, Sider } = Layout;

const Home: React.FC = () => {
  const [collapsed, setCollapsed] = useState(false);
  // const navigateTo = useNavigate();

  return (
    <Layout style={{ minHeight: "100vh" }}>
      {/* 左侧侧边栏 */}
      <Sider
        collapsible
        collapsed={collapsed}
        onCollapse={(value) => setCollapsed(value)}
      >
        <div className="logo" />
        <MainMenu/>
      </Sider>
      {/* 右边内容 */}
      <Layout className="site-layout">
        {/* 右边头部 */}
        <Header
          className="site-layout-background"
          style={{ paddingLeft: "16px" }}
        >
          {/* 面包屑 */}
          <Breadcrumb style={{ lineHeight: "64px" }}>
            <Breadcrumb.Item>User</Breadcrumb.Item>
            <Breadcrumb.Item>Bill</Breadcrumb.Item>
          </Breadcrumb>
        </Header>
        {/* 右边内容 */}
        <Content
          className="site-layout-background"
          style={{ margin: "16px 16px 0" }}
        >
          {/* 页面展示部分 根据路由变动 */}
          {/* s【!!!!重点】设置占位符展示窗口
             注意：嵌套路由的占位符展示窗口需要用Outlet组件，这里和根路由的展示有所区别 
             */}
          <Outlet />
        </Content>
        {/* 右边底部 */}
        <Footer style={{ textAlign: "center", padding: 0, lineHeight: "48px" }}>
          Ant Design ©2018 Created by Ant UED
        </Footer>
      </Layout>
    </Layout>
  );
};

export default Home;

```

这样就完成了组件的单独抽取



**为了能让代码看起来更简洁直观，我们对MainMenu中的数据进行整理，没有使用官方的getItem：**

`src/components/MainMenu/index.tsx`

```tsx
import {
    DesktopOutlined,
    FileOutlined,
    PieChartOutlined,
    TeamOutlined,
    UserOutlined,
} from "@ant-design/icons";
import type { MenuProps } from "antd";
import { Menu } from "antd";
import { useState } from "react";
import { useNavigate } from "react-router-dom";

type MenuItem = Required<MenuProps>["items"][number];

// 登录请求到数据，就可以跟items这个数组进行匹配，根据登录用户权限来决定展现什么内容
const items: MenuItem[] = [
    {
        label: '栏目1',
        key: '/page1',
        icon: <PieChartOutlined />,
    },
    {
        label: '栏目2',
        key: '/page2',
        icon: <DesktopOutlined />,
    },
    {
        label: '栏目3',
        key: 'page3',
        icon: <UserOutlined />,
        children: [
            {
                label: '栏目301',
                key: '/page3/page301'
            },
            {
                label: '栏目302',
                key: '/page3/page302'
            },
            {
                label: '栏目303',
                key: '/page3/page303'
            }
        ]
    },
    {
        label: 'Team',
        key: '栏目4',
        icon: <TeamOutlined />,
        children: [
            {
                label: '栏目401',
                key: '/page4/page401'
            },
            {
                label: '栏目402',
                key: '/page4/page402'
            }
        ]
    },
    {
        label: '栏目5',
        key: '/page5',
        icon: <FileOutlined />
    }
]
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230706144953149.png" alt="image-20230706144953149" style="zoom:50%;" />

# 十五、配置其余路径的跳转

我们在MainMenu的其他项目都配备了对应的key，并且在views创建好了对应的组件Page301,现在我们要着手在路由表中进行配置:

`src/router/index.tsx`

```tsx
// 定义懒加载模块
const About = lazy(() => import('@/views/About'))
const Page1 = lazy(() => import('@/views/Page1'))
const Page2 = lazy(() => import('@/views/Page2'))
const Page301 = lazy(() => import('@/views/Page301'))

/**
 * @description: 将懒加载的组件外层包裹一个React.Suspense标签 用来展示加载中的组件
 * @param {JSX.Element} lazyLoadComponentTagName 需要进行懒加载的组件
 * @return {JSX.Element}
 */
const withLazyLoadComponent = (lazyLoadComponentTagName: JSX.Element) => {
    return (
        <React.Suspense fallback={<div>Loading...</div>}>
            {lazyLoadComponentTagName}
        </React.Suspense>
    )
}

const routes = [
    // 嵌套路由 开始------------------
    {
        // 这里是检测到后面没有路径，则配置重定向到page1
        path: '/',
        element: <Navigate to='/page1' /> // 使用重定向组件 重定向到Page1
    },
    {
        // 定义展示home路由及其子路由
        path: '/',
        element: <Home/>,
        children: [
            {
                path: '/page1',
                element: withLazyLoadComponent(<Page1/>)
            },
            {
                path: '/page2',
                element: withLazyLoadComponent(<Page2/>)
            },
            {
                path: '/page3/page301',
                element: withLazyLoadComponent(<Page301/>)
            }
        ]
    },
    // 嵌套路由 结束------------------

    // 配置路由表以外的所有路径重定向
    {
        path: '*',
        element: <Navigate to='/page1' /> // 使用重定向组件 重定向到Page1

    },
    {
        path: '/home',
        element: <Home />
    },

    {
        path: '/about',
        // 使用懒加载的组件的写法，外面需要套一层类似Loading的标签来向用户提示加载组件
        element: withLazyLoadComponent(<About/>)
    }
]
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230706145319637.png" alt="image-20230706145319637" style="zoom:50%;" />

这里我们不仅为Page301组件配备了路由规则，而且还为访问非路由表中记录的其他路径进行了重定向（到Page1组件）

```tsx
    // 配置路由表以外的所有路径重定向
    {
        path: '*',
        element: <Navigate to='/page1' /> // 使用重定向组件 重定向到Page1

    },
```

**这里我们发现了一个小bug：**

在我们选定page2项目然后再刷新的时候 发现当前样式没有跟上

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230706161449458.png" alt="image-20230706161449458" style="zoom:50%;" />

这是因为样式是由菜单组件中的一个API`defaultSelectedKeys`决定的

由于我们每次选择项目的时候都会跳转路由，而我们规定将key和路由跳转的path是一样的，我们可以通过useLocation这个Hook拿到我们的路由路径，然后再把这个值放入`defaultSelectedKeys`里来指定样式选择

```tsx
    const currentRouteObj = useLocation()
    console.log(currentRouteObj);
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230706161811516.png" alt="image-20230706161811516" style="zoom:50%;" />

log会打印两次是因为严格模式 详情见：https://blog.csdn.net/HYHhmbb/article/details/125973790

拿到这里的pathname属性再传入`defaultSelectedKeys`中

```tsx
        <Menu
            theme="dark"
            // 表示当前的样式所在的选中项 通过key传递
            defaultSelectedKeys={[currentRouteObj.pathname]}
            mode="inline"
            // 菜单项的数据
            items={items}
            onClick={menuClick}
            // 某项菜单展开和回收的事件
            onOpenChange={handleMenuOpenChange}
            // 当前展开的菜单项key数组
            openKeys={openKeys}
        />
```

这样就能够解决我们的样式选择问题了
